{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2021/10/01/hello-world/"},{"title":"Webpack Loader","text":"loader 定义webpack 只能理解 js 和 json 格式的文件，loader 可以让 webpack 有了能处理其他类型文件的能力，处理它们的源码并将它们转换成有效模块。 webpack 中配置方式12345678910module.exports = { module: { rules: [ { test: /\\.js$/, use: 'babel-loader' } ] }} rule 中的对象包含两个必要的字段： test：正则表达式，用于匹配需要处理的文件类型 use：处理该类型文件需要使用的 loader loader 的执行loader 支持链式调用，并且它的取值/执行顺序从后往前进行，如： 12345678910module.exports = { module: { rules: [ { test: /\\.css$/, use: ['style-loader', 'css-loader'] } ] }}","link":"/2021/10/18/webpack-loader/"},{"title":"Webpack Plugin","text":"Plugin 含义及使用Plugin 选项用于以各种方式自定义 webpack 构建过程。webpack 附带了各种内置插件，可以通过 webpack.[plugin-name] 访问这些插件。 webpack 中 plugin 配置方法如下： 12345678module.exports = { //... plugins: [ new webpack.DefinePlugin({ // Definitions... }), ],}; Plugin 的基本组成它是一个定义的类 class 或者方法 function，通过设置类的 apply 方法或者 function.prototype.apply 方法来将用户自定义的方法绑定到 webpack compiler 的钩子上，从而实现在对应的 webpack 打包阶段进行相应的自定义操作。 webpack 插件基本组成如下： 1234567891011class ExamplePlugin { // 插件参数 constructor (options = {}) { ... } // 在插件函数的 prototype 上定义一个 `apply` 方法，以 compiler 为参数。 apply(compiler) { // ... }} webpack 插件结构分析contructor 构造函数主要对传入的参数进行操作（赋值，校验等）12345678910111213141516171819202122232425const { validate } = require('schema-utils')const schema = { type: 'object', required: [], properties: { targetPath: { type: 'string', }, outputFilePath: { type: 'string', } },};class ExamplePlugin { constructor(options = {}) { validate(schema, options) this.options = options } apply(compiler) { // ... }} schema-utils：校验 json 数据格式 apply 方法主要是对 compiler 对象中的钩子绑定对应的方法去自定义打包过程中的一些操作1234567891011class ExamplePlugin { constructor(options = {}) { // ... } apply(compiler) { compiler.hooks.thisCompilation.tap(pluginName, (compilation) =&gt; { // ... }); }} webpack compilerapply 方法带有一个参数 compiler，它是 webpack 的实例，里面包含了所有构建过程中的对象。一般通过 compiler.hooks.[阶段名称]来访问和对该阶段挂载钩子。 compiler 有很多钩子，表示了构建过程中的不同阶段，例如： thisCompilation（初始化 compilation 时调用，在触发 compilation 事件之前调用） emit（输出 asset 到 output 目录之前执行） done（在 compilation 完成时执行） 钩子里面暴露了三个方法，用于挂载事件： tap tapAsync tapPromise 其使用如下： 123456789101112131415tapAsync(pluginName, callback)apply(compiler) { // emit钩子还有一个 callAsync 方法，用于 emit 阶段时，内部用 compiler.hooks.emit.tapAsync( pluginName, // emit 钩子还有 callAsync 方法，主要调用第二个参数-方法的执行，callAsync 主要用于内部实现，开发者不会用到。 (compilation, callback) =&gt; { // dosomething about compilation // ... callback() } )} compiler 实现原理compiler 的钩子实现扩展于一个工具库 — Tapable。 Tapable 工具库暴露了 9 个钩子类。它的钩子类对外暴露了 tap、tapAsync、tapPromise 等方法。插件可以通过这些方法，向构建过程注入自定义行为。 SyncHook SyncBailHook SyncWaterfallHook SyncLoopHook AsyncParallelHook AsyncParallelBailHook AsyncSeriesHook AsyncSeriesBailHook AsyncSeriesWaterfallHook 所有这些钩子都来源于一个公共的基础类 - Hook tapable 钩子使用： 12345678910111213141516const { SyncHook, AsyncParallelHook } = require('tapable')// hook 使用// arg1、arg2 为钩子调用时的参数const hook = new SyncHook(['arg1', 'arg2'])// 在类中定义钩子方法class Car { constructor () { this.hooks = { accelerate: new SyncHook([&quot;newSpeed&quot;]), brake: new SyncHook(), calculateRoutes: new AsyncParallelHook([&quot;source&quot;, &quot;target&quot;, &quot;routesList&quot;]) } }} webpack 中 compiler 的定义扩展自 Tapable 中的这些钩子（github源码） 1234567891011// apply 中的参数 compiler 定义如下class Compiler { constructor () { this.hooks = { thisCompilation: new SyncHook([&quot;compilation&quot;, &quot;params&quot;]), emit: new AsyncSeriesHook([&quot;compilation&quot;]), done: new AsyncSeriesHook([&quot;stats&quot;]), // ... } }} compilation同样扩展自 Tapable，定义的钩子方式与 compiler 一样。compilation 实例能够访问所有模块和他们的依赖。（案例部分会有演示） 实战：自定义插件使用（找出项目中所有未引用的文件）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152const fs = require('fs')const path = require('path')// 根据路径，获取其下所有的文件名称const getAllFiles = (url) =&gt; { const res = [] const getRes = (url) =&gt; { const list = fs.readdirSync(url) list.forEach(item =&gt; { const file = path.resolve(url, item) const stat = fs.statSync(file) if (stat.isFile()) { res.push(file) } else ( getRes(file) ) }) } getRes(url) return res}class ExamplePlugin { constructor (options = {}) { // ... } apply (compiler) { compiler.hooks.emit.tap('ExamplePlugin', compilation =&gt; { const fileDependencies = [...compilation.fileDependencies].filter(item =&gt; { // 过滤 src 下且带有后缀为文件 return /.*\\/src\\/.*\\..*/.test(item) }) const allFiles = getAllFiles(path.resolve(__dirname, './src')) const invalidFiles = allFiles.filter((item) =&gt; !fileDependencies.includes(item)) console.log(invalidFiles); }) // 其它阶段也可以拿到 fileDependencies，例如： // compiler.hooks.done.tap('ExamplePlugin', stats =&gt; { // const fileDependencies = [...stats.compilation.fileDependencies].filter(item =&gt; { // // 过滤 src 下且带有后缀为文件 // return /.*\\/src\\/.*\\..*/.test(item) // }) // const allFiles = getAllFiles(path.resolve(__dirname, './src')) // const invalidFiles = allFiles.filter((item) =&gt; !fileDependencies.includes(item)) // console.log(invalidFiles); // }) }} webpack 常用插件案例clean-webpack-plugin","link":"/2021/10/18/webpack-plugin/"}],"tags":[],"categories":[]}